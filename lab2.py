from scipy.special import binom
from scipy.stats import entropy
import numpy as np


def SuperBinom(a, b):
    if a < b:
        return 0
    else:
        return binom(a, b)


def Entropy(seq):
    v, c = np.unique(seq, return_counts=True)
    return entropy(c)


def KDC(seq):
    res = []
    ind = 0
    for i in range(len(seq)):
        if (seq[i] == "1"):
            res.append(seq[ind:i+1])
            ind = i + 1
    if ind != len(seq):
        res.append(seq[ind:])

    num_result = []
    for i in res:
        if ("1" in i):
            num_result.append(len(i))
        else:
            num_result.append(0)
    return num_result


def APK(seq, n=4):
    seq = "0"*(n - (len(seq) % n)) + seq
    blocks = [seq[i:i+n] for i in range(0, len(seq), n)]
    res = []
    for elem in blocks:
        for i in range(len(elem)):
            if elem[i] == "1":
                res.append(i)
    return res



def YK(seq, n=4):
    seq = "0" * (n - (len(seq) % n)) + seq
    blocks = [seq[i:i + n] for i in range(0, len(seq), n)]
    res_blks = []
    for b_ind in range(len(blocks)):
        res_block = []
        for i in range(len(blocks[b_ind])):
            if blocks[b_ind][i] == "1":
                res_block.append(i)
        res_blks.append(res_block)
    result = []
    for positions in res_blks:
        bk = [SuperBinom(positions[i] - 1, i + 1) for i in range(len(positions))]
        if positions == []:
            bk = []
        result.append([len(positions), int(sum(bk))])
    result = [bin(i[0])[2:] + bin(i[1])[2:] for i in result]
    result  = [int(i, 2) for i in result]
    return result


def IPP(val):
    return [2, 9, 0, 10, 10, 10, 10]

if __name__ == "__main__":
    test_val = "1010000100000000101010101010100101"
    print("KDC", KDC(test_val), "ENTROPY", Entropy(KDC(test_val)))
    print("APK", APK(test_val), "ENTROPY", Entropy(APK(test_val)))
    print("IPP", IPP(test_val), "ENTROPY", Entropy(IPP(test_val)))
    print("YK", YK(test_val), "ENTROPY", Entropy(YK(test_val)))












